redis分布式

高并发

分布式缓存
队列
数据库分布
分离
中间件
[负载均衡]
读多写少使用缓存
MQ 消息队列
批量查询（redis 70w/s批量 12w/s非批量）

[[[future请求合并]]]

IOC/DI iocontrol 反射

spring原理
1. 根据xml找类文件  加载配置文件 Servlet 解析xml，拿到basePackage
初始化相关类，扫描class
[[读取xml]]

2.（请求处理之前）创建对象，（spring bean容器）保存对象
@Controller @Service（附件信息  让spring托管  创建对象）
注解创建语法 public @interface AnnotationName{}
注解用于表示方法的适用范围
没有注解的，spring不进行创建对象

运行：for读取class信息，进行判断
beanIOCContain.put放入对象


3.需要spring创建的对象都创建完毕
判断是否需要注入，实现注入（[[[反射]]]（赋值））
使用注解判断
@Recource（java）@Autowired（spring）

4.DispatcherServlet（）spring解析注解，保存了url和具体的chontroller对象和method方法的映射（hashmap）
@requestMapping

5.初始化HandleMapping，处理url和controller注解的对应关系

spring mvc处理controller层参数
所有http方法交给doDispatch方法处理

6.利用反射机制调用方法



1事务管理流程

开启事务
执行业务操作
提交/回滚事务

2事务管理情形

单数据源
多数据源

面向接口编程、策略模式

3AOP

4AOP，
根据事务定义开启事务get
try{业务操作}catch（）{回滚}
提交

ThreadLocal
//开启事务
tm.getTransaction(transactionDefination)         //getconnection（connection）
ThreadLocal.put（conncection）
	执行业务方法 insertUser（user）
	执行业务方法 insertLog （log）

spring事务坑
1正确获取Connection

使用DataSourceUtils（从线程上下文获取）

2正确地进行方法调用

如果方法内部调用this.方法，那么注解失效



CDN加速

反向代理


线程：一条代码执行流，完成一组代码的执行，我们称呼这个执行为[任务]
任务：run方法代码块
当类继承线程时，那么类变成线程
当类实现runnalbe时，需要new线程类调用类，并start
call在run方法中运行
cpu的工作：执行代码
一个线程默认最大栈大小1m
任务：用runnable表示/callable表示

callable有一个泛型（返回值）
提供返回值（线程通信）

任务仓库：





## spring-cglib-@configuration

@Configuration
	 为了确保@Bean对象为单例的

spring start
	scan
	prase？类不能直接new的情况
		BeanDefinition
			setBeanClassName
			setScope（“singleton”）
			setBeanClass（x.class）
		放入map //map.put("y",beandefinition)
			//BeanDefinitionMap存在于bean工厂中
			//bdm用于存放bd对象
				//bd对象用于描述该类
			//bdm不存放启动类对象
				//bdm需要扫描将类放入
				//bdm需要启动类才能进行扫描
				//AnnotationConfigApplicationContext.
	register方法进行对注册类的注册（lfb-bd）
					//此时bdm还未进行扫描
					//此时注册类已经被代理
						//代理行为由invokeBeanFactoryPostProcessors执行
							//enhanceConfigurationClasses
			bdm初始存放6个对象（扫描前）
				全域配置注解处理器
				全域事件监听器工厂
				全域事件监听器处理器
				（注册类）
				全域autowired注解处理器
				全域普通注解处理器
			bdm完成了扫描
				spring解析bd，判断是否需要代理
				bean存入bdm
	preInstantiateSingletons new object //进入单例池
		new ClassPathBeanDefinitionScanner

吞吐量

停顿时间
	full gc
类加载子系统
	全盘负责委托机制
	双亲委派模型
	tomcat加载
运行时数据区
gc
jvm调优参数，步骤 

### enhanceConfigurationClasses
判断是否需要代理
	![1571741264706](C:\Users\feketerigo\AppData\Roaming\Typora\typora-user-images\1571741264706.png)
	for（从需要实例化的类名中遍历）
		取bd
			if（该类是否全注解类（@Configuration））
			此时注解类并未被解析，所以并不是全注解类


## 同步机制-ReentrantLock
	自旋：
		另一个线程持续执行CAS
	yield自旋
		获取不到cpu就进行让出cpu
	sleep自旋
		获取不到cpu则sleep
	park自旋
		获取不到cpu则park

ReentratantLock
	排他锁√/共享锁
		排他锁不允许其他人加锁
		共享锁允许其他人加锁并执行
	公平锁√/非公平锁

AbstractQueuedSynchronizer







