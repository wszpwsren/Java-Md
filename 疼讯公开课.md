# redis分布式

高并发

分布式缓存
队列
数据库分布
分离
中间件
[负载均衡]
读多写少使用缓存
MQ 消息队列
批量查询（redis 70w/s批量 12w/s非批量）

[[[future请求合并]]]

IOC/DI iocontrol 反射

# spring原理

1. 根据xml找类文件  加载配置文件 Servlet 解析xml，拿到basePackage
初始化相关类，扫描class
[[读取xml]]

2.（请求处理之前）创建对象，（spring bean容器）保存对象
@Controller @Service（附件信息  让spring托管  创建对象）
注解创建语法 public @interface AnnotationName{}
注解用于表示方法的适用范围
没有注解的，spring不进行创建对象

运行：for读取class信息，进行判断
beanIOCContain.put放入对象


3.需要spring创建的对象都创建完毕
判断是否需要注入，实现注入（[[[反射]]]（赋值））
使用注解判断
@Recource（java）@Autowired（spring）

4.DispatcherServlet（）spring解析注解，保存了url和具体的chontroller对象和method方法的映射（hashmap）
@requestMapping

5.初始化HandleMapping，处理url和controller注解的对应关系

spring mvc处理controller层参数
所有http方法交给doDispatch方法处理

6.利用反射机制调用方法



# 1事务管理流程

开启事务
执行业务操作
提交/回滚事务

2事务管理情形

单数据源
多数据源

面向接口编程、策略模式

3AOP

4AOP，
根据事务定义开启事务get
try{业务操作}catch（）{回滚}
提交

ThreadLocal
//开启事务
tm.getTransaction(transactionDefination)         //getconnection（connection）
ThreadLocal.put（conncection）
	执行业务方法 insertUser（user）
	执行业务方法 insertLog （log）

spring事务坑
1正确获取Connection

使用DataSourceUtils（从线程上下文获取）

2正确地进行方法调用

如果方法内部调用this.方法，那么注解失效



# CDN加速

反向代理


线程：一条代码执行流，完成一组代码的执行，我们称呼这个执行为[任务]
任务：run方法代码块
当类继承线程时，那么类变成线程
当类实现runnalbe时，需要new线程类调用类，并start
call在run方法中运行
cpu的工作：执行代码
一个线程默认最大栈大小1m
任务：用runnable表示/callable表示

callable有一个泛型（返回值）
提供返回值（线程通信）

任务仓库：





# spring-cglib-@configuration

@Configuration
	 为了确保@Bean对象为单例的

spring start
	scan
	prase？类不能直接new的情况
		BeanDefinition
			setBeanClassName
			setScope（“singleton”）
			setBeanClass（x.class）
		放入map //map.put("y",beandefinition)
			//BeanDefinitionMap存在于bean工厂中
			//bdm用于存放bd对象
				//bd对象用于描述该类
			//bdm不存放启动类对象
				//bdm需要扫描将类放入
				//bdm需要启动类才能进行扫描
				//AnnotationConfigApplicationContext.
	register方法进行对注册类的注册（lfb-bd）
					//此时bdm还未进行扫描
					//此时注册类已经被代理
						//代理行为由invokeBeanFactoryPostProcessors执行
							//enhanceConfigurationClasses
			bdm初始存放6个对象（扫描前）
				全域配置注解处理器
				全域事件监听器工厂
				全域事件监听器处理器
				（注册类）
				全域autowired注解处理器
				全域普通注解处理器
			bdm完成了扫描
				spring解析bd，判断是否需要代理
				bean存入bdm
	preInstantiateSingletons new object //进入单例池
		new ClassPathBeanDefinitionScanner

吞吐量

停顿时间
	full gc
类加载子系统
	全盘负责委托机制
	双亲委派模型
	tomcat加载
运行时数据区
gc
jvm调优参数，步骤 

# enhanceConfigurationClasses
判断是否需要代理
	![1571741264706](C:\Users\feketerigo\AppData\Roaming\Typora\typora-user-images\1571741264706.png)
	for（从需要实例化的类名中遍历）
		取bd
			if（该类是否全注解类（@Configuration））
			此时注解类并未被解析，所以并不是全注解类


# 同步机制-ReentrantLock
	自旋：
		另一个线程持续执行CAS
	yield自旋
		获取不到cpu就进行让出cpu
	sleep自旋
		获取不到cpu则sleep
	park自旋
		获取不到cpu则park

ReentratantLock
	排他锁√/共享锁
		排他锁不允许其他人加锁
		共享锁允许其他人加锁并执行
	公平锁√/非公平锁

AbstractQueuedSynchronizer

# Hashmap

index计算 hash&（length-1）length默认16
	即与0001111111，一定是小于该位
hashcode右移及与或操作
	高位不影响（后续有与操作↑）
	提高高位对结果的影响（高位低位共同影响）
hashcode扩容
	每次扩容，hash&（length-1）的大小
		不变
		增加扩容前的数组容量数（16）
	可以通过该规律分配新table的位置







# JVM

## 线程共享区域
	方法区
		存储加载的类信息/常量、静态变量、JIT编译的代码等
			类信息
				.class文件（二进制字节码）中表达的信息都为类信息
				//描述一个类
				加载至方法区是以对象方式（类对象）存储
		方法区GC
			回收效率低，主要针对常量池的回收，类型卸载
		JDK7：永生代
		JDK8：堆外内存
	堆内存
		存储new的对象实例，（对象/数组）
			堆为可扩展大小的
			//栈存储引用类型
			//堆中储存对象及引用类型
		堆存储对象结构
			实例字段存在堆内（全局变量）
				实例字段定义的字符串（String）/引用类
					该String/引用类 存在与堆内
			对象头
				对象存储对象头，指向方法区内的类对象（本类）
				类中引用的其他类指向堆内存中的类对象
			//静态字段及方法存在方法区内（类对象）
	GC
		引用计数器法，（循环引用问题）
		可达性分析算法
			GC root，计算起点，连接下一个引用
				虚拟机栈
				方法区中静态属性引用的对象（类对象）
				方法区中常量引用的对象
	
	线程共享区域-存在线程安全问题
		
## 线程独占区域		
	虚拟机栈
		//线程中方法执行的模型
		//每个方法执行时，就会在虚拟机栈中创建一个栈帧
		//调用-》入栈，执行-》出栈
		局部变量表
			即栈
			用于存储局部变量
		操作数栈
			临时存放数据（指令参数）的栈
		动态链接
			链接至方法区的方法上
		返回值地址
			内存地址
	
	
	
	
	
	
	
	