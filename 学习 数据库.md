数据库DataBase
DB
数据库特点：持久化存储数据的
	方便存储及管理
	使用了统一的方式操作数据库
配置：
	net start mysql
	net stop mysql
	mysql -uroot -p	密码0	exit
	mysql -h127.0.0.1 -uroot -p密码	quit
	mysql --host=127.0.0.1 --user=root --password=密码
	
表：文件（frm）

SQL：Structured Query Language
	定义了操作所有关系型数据库的语言
SQL语言
	SQL语句可以单行或多行书写，以分号结尾
	MySQL的SQL语句不区分大小写，关键字建议使用大写
	注释：# 单行注释（MySQL特有）
	-- 单行注释（注意空格）
	/* 多行注释 */
SQL分类：DDL Definition
	数据定义语言
	操作数据库、表
	DML Manipulation
	数据操作语言
	操作数据记录（增删改）
	DQL Query
	数据查询语言
	操作数据记录（查）
	DCL
	数据控制语言
	权限控制

DDL 数据库
	操作数据库
	CRUD	

Create
Retrieve 查询
Update 修改
Delete

使用数据库

Retrieve
Create
查询所有数据库名称：
https://www.sindns.net/info/a/wangluobiancheng/mysql/20160806/1249.html
	[[[show databases]]]
		/不操作	（information_schema不存在对应的物理文件（视图））
		/不操作	mysql 核心数据库
		/不操作	performance_schema 性能提升操作
		sakila 设计数据库的参考
		sys 数据来自performance_schama，performance_schema的复杂度降低，让DBA能更好的阅读这个库里的内容。让DBA更快的了解DB的运行情况。

​	[查看数据库的字符集]（查看某个数据库的创建语句）
​		show create database xxx
​	[创建数据库]
​		create database
​	[判断数据库是否存在]
​		if not exists xxx
​	[设置字符集]
​		create database xxx character set gbk
​		create database if not exists db04 character set gbk;
​	
Update
​	[修改字符集]
​		alter database xxx character set utf8
Delete
​	[删除数据库]
​		drop database if exists xxx
使用数据库
​	[使用数据库]
​		use xxx
​	[查看使用的数据库]
​		select database（）

DDL 定义数据库
Retrieve
	查询所有表
		show tables
	查询表结构
		desc xxx	
Create
创建表
	语法：create table xxx（
	列名1	数据类型1，	
	列名2	数据类型2，	
	列名n	数据类型n
	）
	*数据库数据类型：
		1、int 整数类型
			xxx int
		2、double 浮点数
			xxx double（5，2）//999.99
		3、date 日期//只包含年月日 yyyy-MM-dd
		4、datetime 日期 //年月日时分秒 yyyy-MM-dd HH:mm:ss
		5、timestamp 时间戳 //年月日时分秒 yyyy-MM-dd HH:mm:ss
			如果为timestamp类型，不给这个字段赋值时，则默认使用当前时间赋值
			[[[需要在定义时，将其默认值设为null，dafault设置current_timestamp]]]
		6、varchar 字符串
			xxx varchar (20) :20字符（20char）
Delete
	删除表
		drop table if exists xxx；
	[[复制表]]
		create database xxx like yyy
Update
修改表
	[修改表名]
		alter table yyy rename to xxx；
	[修改表字符集]
		alter table xxx character set gbk;
	[添加列]
		alter table xxx add 列名1，数据类型1
	[修改列的名称/类型]
		alter table xxx change yyy zzz 数据类型
		alter table xxx modify xxx 数据类型（只修改数据类型）
	[删除列]	
		alter table stu drop xxx

DML：操作数据库
添加数据
		insert into xxx（列名1，列名2，...列名n）values（值1，值2,...值n）
			ZY:
				如果表明后，不定义列名，则默认给所有列添加值
				[[[除数字类型]]]，其他类型使用引号（单双都可以\
	
删除数据
		delete from xxx  where 条件
		truncate table stu 删除表，并创建同属性新表
			zy：
				如果不写条件，那么将表内数据全部删除

修改数据
		update xxx set 列名 = 值， 列名 =值... where 条件；
			zy：
				如果不写条件，那么将表内数据全部修改


DQL：查询数据库

查询数据 

语法
		select 字段列表 
		from 表名列表 
		where 条件列表 
		group by 分组字段
		having 分组之后的条件
		order by 排序
		limit 分页限定

多字段查询
	select 字段名1，字段名2，...from 表名；
	如果查询所有字段，可以使用*替代（不常用）
去除重复
	select distinct
计算列
	*一般可以使用四则运算计算一些列的值（一般进行数值型计算）
		[[ifnull（表达式1，表达式2）列名1]] AS 别名1
		*null参与的计算，结果均为null
	表达式1：哪个字段需要判断为null
	表达式2：如果改字段为null，则set该值	

条件查询
1、where子句后跟条件
2、运算符
	between...and
	in(集合)
	like
	占位符：	
		_ 单个任意单个字符
		% 多个任意字符
	is null 
		判断语句中不能用=null 而是is null
		*反义判断为 is not null
	
||&&！

排序查询
	order by 排序字段 排序方式
		*如果不写排序方式则为升序（ASC）

```
-- 按照pop排名，如果pop一样，那么按照gnp排名
SELECT * FROM country ORDER BY Population ASC , GNP ASC;
```

聚合函数
	将一列数据作为一个整体，进行纵向的计算
	count：计算个数
	max：最大值
	min：最小值
	sum：计算和   *自动排除空值
	avg：计算平均值
	聚合函数的计算排除空值

```mysql
-- 语法	
SELECT COUNT(IFNULL(IndepYear,0)) AS COUNT FROM country;
```

zy：
	选择不包含空值的列进行计算
	选择非空列方式：主键
	IFNULL函数
分组查询
语法	group by 分组字段1；

```
	SELECT Continent --分组字段,AVG(LifeExpectancy) -- 聚合函数 FROM country GROUP BY Continent;
-- avg低于xx不参与统计
	SELECT Continent,AVG(LifeExpectancy),COUNT(`Code`) FROM country WHERE LifeExpectancy > 50 GROUP BY Continent;
-- 分组后count低于15的不显示
	SELECT Continent,AVG(LifeExpectancy),COUNT(`Code`) FROM country WHERE LifeExpectancy > 50 GROUP BY Continent HAVING COUNT(`Code`)>15;
```

zy：
	分组之后，可查询的字段：分组字段，聚合函数1，聚合函数2
	where作用于分组之前，having作用于分组之后
	where后不可以跟聚合函数，having可以跟聚合函数
	聚合函数一般会起别名

分页查询
语法	limit 开始的索引，每页查询条数；、

```
SELECT * FROM country LIMIT 0,3;-- 第一页
SELECT * FROM country LIMIT 3,3;-- 第二页
```

​	公式：开始的索引 = （当前页码-1）*每页
​		zy：
​			分页操作（limit）为方言(mysql)

约束
	概念：对表中的数据进行限定，保证数据得正确性、有效性和完整性
	分类：	

​		主键约束 primary key
​		含义：	非空且唯一
​			一张表只能有一个字段为主键
​			主键为表中记录的标识
​			创建表时添加主键约束
​	

```
	CREATE TABLE stu(
		ID INT PRIMARY KEY, 
		NAME VARCHAR(20)
	);
-- 删除主键	
	ALTER TABLE stu DROP PRIMARY KEY;
-- 修改主键
	ALTER TABLE stu MODIFY ID INT PRIMARY KEY;
```

​		自动增长
​			如果某列为数值类型没使用auto_increment，可以完成自动增长
​			自动增长时，新建数据以上一条数据为基准
​			删除自动增长	

​		非空约束 not null
​			在创建表时创建约束

```
CREATE TABLE stu(
	id INT,
	NAME VARCHAR(20) NOT NULL 
);
ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;	
删除非空约束
ALTER TABLE stu MODIFY NAME VARCHAR(20);
```

​		唯一约束 uinque

```
zy：
	unique不能以该方法删除（方法如下）或添加（删除重复数据）		
		ALTER TABLE stu MODIFY NAME VARCHAR(20);
	修改方式
		ALTER TABLE stu DROP INDEX NAME ;
```

​		外键约束 foreign key

​			让主表的一列成为子表的键，保证数据的正确性
​			外键值可以为null，但不能为字表不存在的数据
​			在创建表时，可以添加外键
​				语法：

```mysql
create table 表名（
	...
	外键列
constant 外键名称 foreign key 外键列名称 reference 主表名称（主表列/* 一般用主键*/名称）
）

CREATE TABLE employee(
	id INT PRIMARY KEY AUTO_INCREMENT,
	`Name` VARCHAR(20),
	age INT,
	dep_id INT,
	CONSTRAINT emp_dept_id FOREIGN KEY (dep_id) REFERENCES department(id);
)
	删除外键
alter table employee drop foreign key emp_dept_fk	
	在创建表后，添加外键
alter table employee add constraint emp_dept_fk foreign key (dep_id) references department(id)
```

级联操作

​	操作父表外键数据，之后用级联替代

```
UPDATE employee SET dep_id = NULL WHERE dep_id = 1;
UPDATE employee SET dep_id = 5 WHERE dep_id = NULL;
```

​	添加外键，设置级联更新，设置级联删除

```
alter table employee add constraint emp_dept_fk foreign key (dep_id)  references department(id) ON UPDATE CASCADE ON DELETE CASCADE；
```

数据库的设计——范式
	1、多表之间的关系
		1、一对一关系
			在任意一方建立外键（且unique），指向另一方的主键
		2、一对多关系/多对一关系实现
			在多的一方建立外键，指向一的一方的主键
		3、多对多关系实现
			建立中间表t_student_class
			列sid=student主键  列cid=class主键
			着两个字段作为第三张表的外键——联合主键
	2、范式
		第一范式：
			表的每一列都是不可分割的数据原子项
		第二范式：
			在1NF的基础上，非码属性必须完全依赖于候选码
			（在1NF基础上消除非主属性对主码的部分函数依赖）
				函数依赖：
					完全函数依赖：A-确定->B，那么B依赖于A属性（A属性组）
					部分函数依赖：A属性组-确定->B,那么B依赖于A属性组的某些属性
					传递函数依赖：A->B->C，C传递依赖A
					[码]：一个属性或[属性组]在一张表中，被其他所有属性依赖，则称其为码
					主属性：码属性组中所有的属性
					非主属性：表中除码属性组其他的属性

​		第三范式：
​		在2NF的基础上，任何非主属性不依赖于其他非主属性
​		（在2NF基础上消除传递依赖）

数据库的备份和还原
	1、命令行
		备份

​	mysqldump -u uest -p password  数据库名 > 保存的路径
​	还原

​	登陆-创建数据库-使用数据库
​	source 文件路径

2、UI
	还原：执行sql脚本

多表查询

```
语法：
	select 列名 from 表名 where
```

笛卡尔积
	A X B
	笛卡尔积得出的不一定都是正确的数据，需要消除无用的数据

多表查询的分类：
	内连接查询
			zy：
				1、从哪些表中查数据
				2、查询条件是什么
				3、查询哪些字段
		1、隐式内链接
		使用where条件消除无用数据

```
SELECT * FROM country,countrylanguage WHERE `Code`=CountryCode;
```

```
SELECT 
	c1.GovernmentForm,
	c2.`Language`,
	c2.Percentage
FROM
	country c1,
	countrylanguage c2
WHERE
	c1.CODE = c2.CountryCode;
```

​		2、显式内链接
​		语法：select 字段列表 from 表名（单表） inner join 表名 on 条件
​		-- inner可省略

```
SELECT
	c1.`Name`,
	c2.`Language`,
	c2.Percentage
FROM
	country c1
INNER JOIN
	countrylanguage c2
ON
	c1.`Code`=c2.CountryCode;
```

​	外连接查询
​		1、左外连接
​				-- outer可省略
​				-- 当需要外接表，但不能限定外键非空时
​				-- 查询的是左表的所有数据及外表数据（以ON的数据为外键）
​			语法：select 字段列表 from 表1 left outer join 表2 on条件

```
SELECT 
	c1.name,
	c2.*
FROM
	country c1
LEFT JOIN
	countrylanguage c2
ON
	c1.`Code`=c2.CountryCode;
```

​		2、右外连接
​		-- 查询的是右表的所有数据及外表数据（以ON的数据为外键）

子查询
		

```
概念：查询中嵌套查询，称嵌套的查询为子查询
SELECT * FROM country WHERE SurfaceArea = (SELECT MAX(SurfaceArea) FROM country );

​	子查询的结果是单行单列的：
​		子查询可以作为条件，使用运算符判断
SELECT * FROM country WHERE SurfaceArea <(SELECT AVG(SurfaceArea) FROM country );
​		
​	子查询的结果是多行单列的：
​		子查询可以作为条件，使用运算符 IN判断
SELECT * FROM country WHERE CODE IN (SELECT CountryCode FROM countrylanguage WHERE LANGUAGE = "english" OR LANGUAGE = "chinese");

​	子查询的结果是多行多列的
​		子查询作为虚拟表，放在from后作为条件
SELECT * FROM countrylanguage c1,(SELECT * FROM country WHERE Population >10000000) q1 WHERE c1.CountryCode= q1.`Code`;
```

事务：
	概念：
	如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败
	操作：
		开启事务：start transaction
		回滚：rollback
		提交事务：commit
	MySQL数据库中事务默认自动提交  
		-- 每条DML提交一次事务
		-- Oracle默认手动提交事务
		-- 事务提交的方式：自动提交（如↑）/手动提交
		-- 手动提交：需要先开启事务
		修改事务的默认提交方式-- SELECT @@autocommit;,value为1则自动提交

四大特征：
	原子性：不可拆分（同时成功/失败）
	持久性：当事务提交或回滚后，数据库会持久化地保存数据
	隔离性：多个事务之间相互独立（分隔离级别）
	一致性：事务必须使数据库从一个一致性状态变换到另一个一致性状态

事务的隔离级别：
	多个事务之间相互隔离。如果多个事务并发，通过设置隔离级别解决问题
	存在问题

脏读：一个事务，读取到另一个事务中没有提交的数据
不可重复读（虚读）：同一个事务中，两次读取到的数据不一样
幻读：一个事务DML数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改

		隔离级别：
			read uncommited：读 未提交
				会产生问题：脏读、虚读、幻读
			read commited： 读 已提交（Oracle默认）
				会产生问题：虚读、幻读
			repeatable read： 可重复读（mysql默认）
				会产生问题：幻读
			serializable：串行化（锁表）
				无问题
		zy：隔离级别从小到大，安全性越来越高，性能越来越低
		查询隔离级别：select @@tx_isolation；
		设置隔离级别：set global transaction isolation level 级别字符串；-- 重启数据库生效

DCL 管理用户、授权
	添加用户
		create user “用户名“@”主机名” identified by “密码”；
		通配符：%表示可以在任意主机使用用户登录（“用户名”@“%”）
	删除用户
		drop user
	修改用户密码
		set password for “用户名”@“主机名” = password（“新密码”）；
	查询用户
		切换至mysql数据库，查询uesr表
