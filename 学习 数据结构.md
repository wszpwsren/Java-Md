Collection
	Array	数组 存储基本类型与对象
	Arraylist	集合 存储对象

数据结构
	栈、队列、数组、链表、红黑树

​	栈：先进先出
​	队列queue：先进后出
​	数组：查询快，增删慢
​		数组的地址是连续的，通过数组首地址可以找到数组
​		数组的长度是固定的，增删需要创建新数组
​	链表：查询慢，增删快
​		链表的每个节点包含一个数据源，两个指针域（自己地址，下一个节点地址）
​		双向链表：其中有两条链，一条记录元素的顺序

​			https://blog.csdn.net/mymottoissh/article/details/82826709
​			c++ java 数据结构对比
​			java 集合：每次添加一个数据之前，都要保证数组中有比现有数据长度多1的容量，如果保证不了，则会创建一个新的容量为以前1.5倍的数组，并把元素进行复制。

红黑树
	二叉树：分支不多于两个
	排序树/查找树：二叉树的基础上，元素大小有排序
		[左子树小，右子树大]
	平衡树：左子树与右子树相等（数量）
	不平衡树：↑不相等

​	红黑树：特点：趋近于平衡树，查询速度很快，查询最大次数不大于最小次数2倍
​		节点可以是红/黑
​		根节点是黑
​		空节点是黑
​		红色的节点的子节点是黑
​		任何一个节点到其每一个子节点的所有路径上黑色节点相同

List集合
	add remove set get
	Arraylist集合
	底层是数组
	LinedList
	List集合的双向链表
	addFirst addLast
	pop 弹栈 push 压栈
		[使用LinkedList特有的方法，不能使用多态]

Vector
	可以实现可增长的对象数组
	vector是同步的

Set接口
	1.不存储重复元素
	2.没有索引，不能使用带索引的方法

HashSet
	3.无序集合
	4.底层哈希表
		哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址值，但不是物理地址，而是逻辑地址）

Object中有一个方法获取Hash值hashCode
	public native int hashCode();
		native调用的是本地操作系统的方法

toString调用的是16进制的hashCode
	[[可以通过覆写方法使逻辑地址相等，但物理地址不相同，所以==为false]]

String类的Hash值重写了Object类的hashCode方法
	同数据的hashCode 相同

哈希表
	JDK1.8前为数组+链表
	JDK1.8后为数组+红黑树

​	哈希表数据结构：把相同哈希值的元素分到一组中，用链表/红黑树的结构把相同哈希值的元素连接起来
当每组元素超过8个时，将链表转为红黑树

​	哈希冲突：元素不同，但哈希值相同。

Set集合不允许重复元素
	Set集合在调用add方法的时候，会调用元素的hashCode方法和equals方法，判断重复（重写hashCode方法）（重写equals方法）

HashSet存储自定义类型元素
	需要（重写hashCode方法）（重写equals方法）

LinkedHashSet
	底层是一个哈希表（数组+链表/红黑树）+链表[[记录元素的存储顺序]]

可变参数[JDK1.5之后]
	使用前提：方法的参数列表数据类型已确定，参数个数不确定
	定义方法时使用
	修饰符 返回值类型 方法名（数据类型 ...变量名）{}
	可变参数的原理：
	可变参数底层是一个数组，根据传递参数个数不同，创建不同长度的数组，来储存这些参数
	传递的参数个数，可以为0，或多个
	[[[底层是一个数组]]]
注意事项：一个方法的参数列表只能由一个可变参数
	如果方法的参数有多个，那么可变参数必须写在参数列表的[[末尾]]

特殊写法：public static void xxx（Object...ob）{}


Collections[[[s]]] 操作 工具类

​	Collections.addall(xxx , //elements "","","","" )
​	Collections.shuffle(xxx)乱序排序
​	Collections.sort(xxx)按照默认规则排序
​		需要为可排序的类，需要实现Comparable接口，覆写compareTo方法，按照其中规则排序
​			

```
public class xxx implements Comparable<xxx>
	public int compareTo（xxx  x）{return 0；//认为元素都相同}
	return this.getAge() - o.getAge() //升序排序
	return o.getAge() - this.getAge（） //降序排序
```

sort（list<T>list,Comparator<? super T>）
	Comparable：this.xxx与参数比较，需要实现Comparable接口，覆写comparaTo方法
	Comparator：第三方

```
Collections.sort(list01,new Comparator<Integer>){
	@override
	public int compare(Integer o1, Integer 02){
	return o1-o2;//升序
	//return o1.getAge() -o2.getAge()
}
//组合排序
	int res = o1.getAge()-o2.getAge();
	if(res == 0){
		result = o1.getName().charAt(x)-o2.getName().charAt(x)
	}
	return res;
}
```

Map
	双列集合（Map<k,v>）(相对Collection单列集合)
	key——>value

HashMap<k,v>
	底层哈希表-->数组+单链表/红黑树

Map常用方法
	put 如果k不重复，v返回NULL，如果k重复，返回被替换的v
	get k->v
	remove k->v,如k不存在，返回NULL
	containsKey
	keySet 遍历
	entrySet 遍历

Map遍历方法
	[单列集合添加add，双列集合添加put]
		1.Set<K> keySet() 把Map集合中所有的key取出并存储到<String>Set集合中-><String>Set get(key)获取相应value
		2.for（：map.keySet()）{}

Entry 键值对
	当Map集合创建时，那么Map集合中创建一个Entry对象，用于记录键值映射关系
用于遍历Map对象
	Set<Map.Entry<K,V>>entrySet();
	把Map集合内部的多个Entry对象取出并存储到Set集合中

HashMap存储自定义类型键值
	//Map保证key为唯一值：作为key的元素需要重写hashcode方法及equals方法

LinkedHashMap extends hashMap
	有序集合

Map接口的另一个实现类Hashtable
	实现一个hash表，不能存储NULL
	早期双列集合（JDK1.0）
同步（单线程）
	Hashtable和Vector集合一样，在JDK1.2版本后被现金集合（HashMap，ArrayList）取代
	Hashtable的子类properties是一个唯一和IO流相结合的集合

list/set/map（不适用于接口的实现类）静态方法.of（）用于添加多个元素
	[[当集合中储存的元素数量已确定时使用]]
	of方法的返回值是一个不能改变的集合
		Set接口和Map接口在调用of方法的时候，不能有重复的元素


